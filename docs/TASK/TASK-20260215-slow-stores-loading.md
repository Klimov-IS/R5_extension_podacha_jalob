# TASK: Критически медленная загрузка списка магазинов

**Дата:** 2026-02-15
**Приоритет:** Высокий
**Адресат:** Backend Team
**Компонент:** API endpoint `GET /api/extension/stores`

---

## Суть проблемы

При открытии расширения загрузка списка магазинов занимает **катастрофически долгое время**. Пользователи ждут по 10-30+ секунд, прежде чем появится дропдаун с выбором магазина. Это блокирует всю работу — пока магазины не загрузились, ничего делать нельзя.

---

## Как работает расширение (контекст для бэкенда)

Расширение автоматизирует подачу жалоб на отзывы в Wildberries Seller Portal. Полный цикл работы:

```
1. Пользователь открывает diagnostic.html (UI расширения)
2. Расширение загружает список магазинов ← ТУТ ТОРМОЗИТ
3. Пользователь выбирает магазин из дропдауна
4. Нажимает "Получить жалобы" → GET /api/extension/stores/{storeId}/complaints
5. Получает список жалоб в статусе draft
6. Нажимает "Подать жалобы" → расширение автоматически:
   - Ищет отзывы на странице WB по артикулу + рейтинг + дата
   - Открывает форму жалобы, заполняет и отправляет
   - Отмечает жалобу как отправленную → POST .../complaint/sent
   - Синхронизирует статусы → POST /api/extension/review-statuses
```

**Шаг 2 — узкое место.** Без списка магазинов пользователь не может ничего сделать.

---

## Что именно запрашивает расширение

### Запрос

```
GET /api/extension/stores
Authorization: Bearer {token}
Content-Type: application/json
```

### Ожидаемый ответ

```json
[
  {
    "id": "store-uuid-123",
    "name": "Название магазина",
    "isActive": true,
    "draftComplaintsCount": 42
  },
  ...
]
```

### Как используется ответ

- Фильтруем по `isActive === true`
- Показываем `name` + `draftComplaintsCount` в дропдауне
- `id` сохраняется для последующих запросов

Данные лёгкие — массив из 5-20 объектов с несколькими полями. Ответ не должен быть большим.

---

## Замеры со стороны расширения

На стороне расширения мы добавили performance-метрики. Типичные результаты:

| Этап | Время |
|------|-------|
| Начало fetch | 0 мс |
| Ответ получен | **10 000 — 30 000+ мс** |
| JSON парсинг | 1-2 мс |
| Отрисовка UI | 1-3 мс |

**Вывод: 99.9% времени — ожидание ответа от сервера.** Парсинг и UI мгновенные.

---

## Что мы уже сделали на стороне расширения

1. **Добавили кэширование** — после первой загрузки магазины кэшируются на 5 минут в `StoreManager`. Повторные открытия diagnostic.html отдают данные мгновенно из кэша.

2. **Перенесли загрузку в background** (Service Worker) — раньше каждая страница diagnostic.html делала свой fetch. Теперь один StoreManager в background обслуживает все запросы.

Но **первая загрузка** всё равно зависит от скорости ответа бэкенда, и она критически медленная.

---

## Что нужно проверить на бэкенде

### 1. Время ответа endpoint'а

```bash
# Простой замер
time curl -s -o /dev/null -w "%{time_total}" \
  -H "Authorization: Bearer {token}" \
  -H "Content-Type: application/json" \
  "http://158.160.217.236/api/extension/stores"
```

Ожидание: < 500 мс. Факт: 10-30+ секунд.

### 2. Что может тормозить

- **Тяжёлый SQL-запрос** — возможно, при формировании ответа считается `draftComplaintsCount` через JOIN/подзапрос по всем жалобам каждого магазина. Если таблица жалоб большая, это будет медленно.
- **Отсутствие индексов** — проверить индексы на таблицах `stores`, `review_complaints` (по `store_id`, `status`).
- **N+1 проблема** — если для каждого магазина делается отдельный запрос к таблице жалоб вместо одного агрегирующего запроса.
- **Cold start** — если сервер/контейнер "засыпает" и первый запрос его "будит".
- **Нет connection pooling** — каждый запрос открывает новое соединение к БД.

### 3. Возможные решения

| Решение | Сложность | Эффект |
|---------|-----------|--------|
| Добавить индекс на `review_complaints(store_id, status)` | Низкая | Ускорит подсчёт `draftComplaintsCount` |
| Кэшировать `draftComplaintsCount` в таблице stores | Средняя | Убирает подсчёт при каждом запросе |
| Сделать отдельный лёгкий endpoint без `draftComplaintsCount` | Низкая | Быстрая загрузка, count грузим отдельно |
| Добавить Redis/in-memory кэш на бэкенде | Средняя | Мгновенные повторные ответы |
| Оптимизировать SQL (один запрос с GROUP BY) | Низкая | Убирает N+1 |

---

## Endpoint'ы, которые использует расширение

Для полноты картины — все endpoint'ы, к которым обращается расширение:

| Метод | Endpoint | Когда вызывается |
|-------|----------|------------------|
| GET | `/api/extension/stores` | **При открытии UI (ТОРМОЗИТ)** |
| GET | `/api/extension/stores/{storeId}/complaints?limit=300&filter=draft&rating=1,2,3` | При нажатии "Получить жалобы" |
| POST | `/api/extension/stores/{storeId}/reviews/{reviewId}/complaint/sent` | После каждой успешной подачи жалобы |
| POST | `/api/extension/review-statuses` | Синхронизация статусов (батчи по 100) |

---

## Как воспроизвести

1. Открыть расширение (diagnostic.html)
2. Смотреть в консоль — логи с таймингами `[Diagnostic] ⏱️`
3. Или просто замерить curl-запрос к `/api/extension/stores`

---

## Проблема с памятью: проверить размер объекта complaint

Помимо медленной загрузки магазинов, мы обнаружили критическую проблему с памятью: **вкладка Chrome занимает 1 ГБ при загрузке всего 9 жалоб**.

Со стороны расширения мы уже устранили лишние копирования объектов. Но нужно проверить: **какой размер одного объекта complaint из API?**

```bash
# Замер размера ответа для 1 жалобы
curl -s -H "Authorization: Bearer {token}" \
  "http://158.160.217.236/api/extension/stores/{storeId}/complaints?limit=1&filter=draft" \
  | wc -c
```

**Если один complaint весит > 1 МБ** (например, base64-картинки внутри `complaintText`), то это главная причина. Ранее расширение создавало 5+ копий каждого объекта через spread и сериализацию — мы это исправили, но если сами данные избыточно большие, проблема будет повторяться при увеличении числа жалоб.

**Ожидаемый размер одного complaint:** < 10 КБ (JSON с текстовыми полями).

---

## Контакт

При вопросах по расширению — обращаться к Extension Team.
