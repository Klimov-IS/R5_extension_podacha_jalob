# TASK — WB Extension: Chat Workflow (открытие чатов + связка отзыв ↔ чат)

> **Статус:** В работе (Chat Status Sync завершён, следующий шаг — MVP реализация)
> **Дата:** 2026-02-19 (обновлено)
> **Sprint:** 2 — Review-Chat Linking
> **API:** Задеплоен в прод, контракт согласован

---

## Контекст

У нас есть Chrome-расширение Rating5 для WB, которое уже:
- парсит страницу отзывов/элементы UI, умеет кликать кнопки;
- получает с бэкенда правила по артикулам (активен/неактивен, по каким звёздам работаем и т.д.);
- ранее фокус был на жалобах; теперь добавляем workflow по чатам.

Ключевая бизнес-проблема: по API WB отзывы и чаты **никак не связаны**, из-за чего мы не можем уверенно понять "какой чат относится к какому отзыву/товару".

### Бизнес-логика (почему чат только после отклонения жалобы)

```
Путь 1 (бесплатный): Жалоба → WB удовлетворяет → Отзыв удалён  (стоимость: ~0)
Путь 2 (платный):    Жалоба → WB отклоняет → Чат → Компенсация → Удаление (стоимость: 50-500₽)
```

Мы **никогда не открываем чат, если жалоба ещё не отклонена** — сначала бесплатный путь.

---

## Цель

### MVP (текущий этап)

1) На странице отзывов WB находить отзывы, подходящие под правила, и нажимать **«Открыть чат»**.
   - Кликаем **ВСЕ** не-disabled кнопки чата: и серые (новый чат), и чёрные (уже открытый) — чтобы наполнить БД полной информацией.
2) В открывшейся вкладке чата:
   - сохранить **URL чата** и отправить в бэкенд (`POST /chat/opened`);
   - спарсить и отправить в бэкенд **первое системное сообщение WB**: "Чат с покупателем по товару {nmId}" (`POST /chat/{id}/anchor`), чтобы связать отзыв ↔ чат.
3) **MVP НЕ включает** отправку сообщений покупателю — только открытие, парсинг, отправка данных в БД.

### Sprint 2 (отправка сообщений)

4) Отправить стартовое сообщение покупателю:
   - для **1–3 звёзд**: шаблон A
   - для **4 звезды**: шаблон B
5) **Архитектурное решение (TBD):** кто отправляет сообщения:
   - **Вариант 1 (по умолчанию):** бэкенд отправляет сообщение через WB API
   - **Вариант 2 (для кабинетов без API):** расширение отправляет через UI
   - Некоторые кабинеты WB **не подключены к API**, поэтому нужен механизм выбора способа отправки

---

## API (согласовано с бэкенд-командой)

> Полный контракт: [API_CHATS_CONTRACT.md](API_CHATS_CONTRACT.md)
> Бэкенд-гайд: [EXTENSION_INTEGRATION_GUIDE.md](EXTENSION_INTEGRATION_GUIDE.md)

### Base URL: `https://rating5.ru`
### Auth: `Authorization: Bearer {api_key}` (тот же токен, что для жалоб)

### Эндпоинты

| # | Method | Endpoint | Фаза | Назначение |
|---|--------|----------|-------|------------|
| 1 | GET | `/api/extension/chat/stores` | MVP | Магазины с чат-правилами |
| 2 | GET | `/api/extension/chat/stores/{id}/rules` | MVP | Правила по артикулам |
| 3 | POST | `/api/extension/chat/opened` | MVP | Фиксация открытия чата → получаем `chatRecordId` |
| 4 | POST | `/api/extension/chat/{id}/anchor` | MVP | Фиксация системного сообщения |
| 5 | POST | `/api/extension/chat/{id}/message-sent` | Sprint 2 | Фиксация отправки сообщения |
| 6 | POST | `/api/extension/chat/{id}/error` | Sprint 2 | Логирование ошибок |

### Ключевые детали API

- **Идемпотентность:** повторный POST /chat/opened с тем же `reviewKey` не создаёт дубль (UPSERT)
- **reviewKey:** `"{nmId}_{rating}_{date_trunc_min}"` — например `"649502497_2_2026-01-07T20:09"`
- **reviewMatched:** бэкенд возвращает `true/false` — удалось ли сопоставить с отзывом в БД (fuzzy match ±2 мин)
- **Reconciliation:** бэкенд сам связывает данные от расширения с dialogue sync (нам не нужно об этом заботиться)
- **Rate limit:** 100 req/min (при maxChatsPerRun=50, cooldown=3s → ~20 req/min, укладываемся)

---

## Входные данные (из бэкенда по API)

Расширение получает правила через `GET /api/extension/chat/stores/{id}/rules`:

```json
{
  "storeId": "store_abc123",
  "globalLimits": {
    "maxChatsPerRun": 50,
    "cooldownBetweenChatsMs": 3000
  },
  "items": [
    {
      "nmId": "649502497",
      "productTitle": "Футболка мужская",
      "isActive": true,
      "chatEnabled": true,
      "starsAllowed": [1, 2, 3],
      "requiredComplaintStatus": "rejected"
    }
  ]
}
```

---

## Критерии отбора отзывов на странице WB

Открываем чат **только если одновременно**:
1. Отзыв относится к артикулу из правил (`nmId`)
2. Товар `isActive = true` и `chatEnabled = true`
3. Звёзды отзыва входят в `starsAllowed`
4. Статус жалобы по этому отзыву = **«Жалоба отклонена»** (`requiredComplaintStatus = "rejected"`)

### Логика кнопки чата

Кнопка чата имеет 3 состояния:
- **Серая** (новый чат) — `button:not([disabled])` — кликаем
- **Чёрная** (чат уже открыт) — `button:not([disabled])` — **тоже кликаем** (для парсинга данных в БД)
- **Прозрачная** (disabled) — `button[disabled]` — **пропускаем**

> Примечание: названия статусов в UI могут меняться. Нужен слой нормализации статусов.

---

## Основной сценарий (end-to-end)

### 1) Страница отзывов
1. Расширение переходит/находится на странице отзывов WB.
2. Загружает правила с бэкенда (`GET /chat/stores/{id}/rules`).
3. Итерирует отзывы (желательно батчами и с прокруткой).
4. Для каждого отзыва:
   - достаёт: `nmId`, `stars`, `complaint_status`, `reviewDate`
   - проверяет критерии отбора
5. Если подходит → кликает **«Открыть чат»**.
   - WB открывает **новую вкладку**.

### 2) Подключение к вкладке чата
1. Расширение ловит событие открытия вкладки (`chrome.tabs.onCreated` / `onUpdated`).
2. Определяет, что это именно вкладка чата WB (по URL-паттерну).
3. Ждёт полной загрузки (document ready + ключевой DOM-элемент чата).
4. Отправляет `POST /chat/opened` → получает `chatRecordId`.

### 3) Сбор данных в чате
Нужно собрать и отправить в бэкенд:
- `chat_url` = текущий URL вкладки
- `system_anchor_message` = первое системное сообщение WB

#### Как искать системное сообщение
- В чате WB есть авто-сообщение в начале: "Чат с покупателем по товару …".
- Алгоритм:
  1. Пытаемся найти его в текущем DOM
  2. Если не нашли — скроллим вверх (постепенно)
  3. На каждом шаге re-scan DOM
  4. Стоп: нашли сообщение ИЛИ достигли начала истории
- Матч по ключам (регистронезависимо): `чат`, `покупател`, `товар`
- И/или по CSS-классу системных сообщений (если есть стабильный)

Результат парсинга → `POST /chat/{id}/anchor`:
- `systemMessageText` (строка как есть)
- `parsedNmId` (если удалось достать из текста)
- `parsedProductTitle` (если есть)

### 4) Отправка стартового сообщения покупателю (Sprint 2, не MVP)

> **Архитектурное решение TBD:** Для кабинетов с WB API — бэкенд отправляет сообщения автоматически. Для кабинетов без API — расширение отправляет через UI.

1. Определяем тип сообщения: `stars in [1,2,3]` → шаблон A; `stars == 4` → шаблон B
2. Проверяем: есть ли уже исходящее сообщение от нас (чтобы не дублить)
3. Отправляем через UI (вставка в поле ввода + клик отправки) — **только если бэкенд не может по API**
4. `POST /chat/{id}/message-sent` → фиксируем результат

### 5) Отправка данных в бэкенд (что отправляем)

**При открытии чата** (`POST /chat/opened`):
- `storeId`, `reviewContext` (nmId, rating, reviewDate, reviewKey), `chatUrl`, `openedAt`

**При нахождении anchor** (`POST /chat/{id}/anchor`):
- `systemMessageText`, `parsedNmId`, `parsedProductTitle`, `anchorFoundAt`, `status`

**При отправке сообщения** (`POST /chat/{id}/message-sent`):
- `messageType` (A/B/NONE), `messageText`, `sentAt`, `status`

**При ошибке** (`POST /chat/{id}/error`):
- `errorCode`, `errorMessage`, `stage`, `occurredAt`

---

## Варианты реализации cross-tab коммуникации

### Вариант A (рекомендуемый): "event-driven tab handshake"
- Перед кликом "Открыть чат" создаём `run_context_id` и кладём в in-memory storage расширения
- По событию открытия вкладки чата подтягиваем `review_context` по последнему ожидаемому `run_context_id`
- Плюсы: минимум вмешательств, быстрый
- Минусы: нужна защита от рассинхронизации

### Вариант B: "URL-based correlation"
- После клика ждём `chrome.tabs.query` и проверяем URL паттерн
- Плюсы: проще
- Минусы: менее надёжно при множественных вкладках

### Вариант C: "content-script ping"
- Content-script в чате отправляет `HELLO_CHAT_TAB` в background, background маппит к pending review_context
- Плюсы: надёжнее и расширяемо
- Минусы: чуть больше кода/шины сообщений

---

## Popup UI

В popup расширения добавляется новая кнопка **«Работа в чатах»**, которая:
- Открывает diagnostic.html в режиме чат-workflow (или отдельную страницу)
- Показывает список магазинов с `pendingChatsCount`
- Позволяет запустить обработку

---

## Ограничения и стоп-условия

Расширение должно остановить текущий run и логировать ERROR, если:
- не удалось определить статус жалобы / звёзды / артикул (DOM изменился)
- вкладка чата не загрузилась за таймаут
- системное сообщение не найдено даже после прокрутки до начала
- поле ввода/кнопка отправки недоступны (бан/ограничение/изменение UI)
- API бэкенда вернул 4xx/5xx (с ретраями по политике ниже)

---

## Ретрай/устойчивость

- **Бэкенд:** retry 3 раза с backoff (1s/3s/7s) на 5xx/сетевые ошибки
- **UI действия:** мягкие ретраи (поиск элемента 5–10 раз с паузой 200–400ms)
- **Дедупликация:**
  - не отправлять повторно стартовое сообщение, если уже есть исходящее (эвристика по последним N сообщениям)
  - не открывать чат повторно для одного и того же отзыва в рамках одного run (локальный set)
  - API сам дедуплицирует по `reviewKey` (UPSERT)

---

## Логирование (обязательно)

Логи должны содержать:
- `run_id`, `storeId`, `nmId`, `stars`, `review_locator` (как нашли отзыв)
- события: `REVIEW_MATCHED`, `CHAT_TAB_OPENED`, `ANCHOR_FOUND/NOT_FOUND`, `MESSAGE_SENT/SKIPPED`, `BACKEND_POST_OK/FAIL`
- ошибки: `ERROR_DOM_CHANGED`, `ERROR_TIMEOUT`, `ERROR_BACKEND`

---

## Безопасность/соответствие

- Никаких секретов в content-script
- API токены — только в background/service worker, хранение через chrome.storage
- Не сохранять в логи персональные данные покупателя

---

## Acceptance Criteria (проверяемое)

### MVP
1. Расширение кликает **все** не-disabled кнопки чата (серые + чёрные) для отзывов, подходящих под правила
2. В чате расширение:
   - отправляет в бэкенд **chat_url** (`POST /chat/opened`)
   - находит и отправляет **system_message_text** (`POST /chat/{id}/anchor`)
   - или падает с понятным `ANCHOR_NOT_FOUND`
3. Повторный запуск не создаёт дубли (идемпотентность API, UPSERT по reviewKey)
4. В случае изменений UI/ошибок — понятные логи + корректное завершение run
5. **Сообщения покупателям НЕ отправляются** — только сбор данных в БД

### Sprint 2 (отправка сообщений)
6. Архитектурное решение: бэкенд (WB API) vs расширение (UI) — по типу кабинета
7. Сообщение покупателю: для 1–3 звёзд шаблон A, для 4 звёзд шаблон B
8. Сообщение не дублируется при повторном запуске (эвристика)
9. Ошибки логируются через `POST /chat/{id}/error`

---

## Definition of Done

- Код покрывает сценарии: чат пустой / чат с историей / сообщение "вверху"
- Добавлены конфиги: таймауты, лимиты (`maxChatsPerRun`, `cooldownBetweenChatsMs`)
- Документация в проекте: селекторы в каталоге, DOM_CONTRACT обновлён
- Демонстрация: видео/скринкаст 1 прохода (5–10 отзывов) + выгрузка логов

---

## План работ

### Этап 0 — Подготовка (завершён)
- [x] Согласован API-контракт с бэкенд-командой
- [x] API задеплоен в прод
- [x] Документация синхронизирована

### Этап 1 — DOM-разведка (завершён 2026-02-17)
- [x] Снять DOM-снимок кнопки «Открыть чат» на странице отзывов
- [x] Снять DOM-снимок страницы чата WB
- [x] Найти селекторы: кнопка чата, системное сообщение, поле ввода, кнопка отправки
- [x] Проверить: можно ли парсить WB review ID из DOM → **НЕТ**, используем синтетический reviewKey
- [x] Проверить формат URL чатов WB → `/chat-with-clients?chatId={UUID}`
- [x] Зафиксировать в DOM_CONTRACT.md и selectors.catalog.js
- [x] Обновить UI_CHANGELOG.md

### Этап 1.5 — Chat Status Sync (завершён 2026-02-19)
- [x] Парсинг состояния кнопки чата (`getChatStatus()` → luminance-based detection)
- [x] Передача `chatStatus` в `POST /api/extension/review-statuses`
- [x] ТЗ для бэкенд-команды (`TZ_CHAT_STATUS_API.md`)
- [x] Бэкенд: приём `chatStatus`, маппинг в ENUM, миграция `017_add_chat_status_opened.sql`
- [x] Бэкенд UI: фильтр "Статус чата" в табе Отзывы
- [x] Документация обновлена (DOM_CONTRACT, UI_CHANGELOG, BACKEND_API)

### Этап 2 — MVP реализация (в работе, 2026-02-19)

> **Архитектурное решение:** объединённый воркфлоу (жалобы + чаты в одном запуске).
> **API бэкенда:** все 4 эндпоинта задеплоены (Sprint 002, 2026-02-16).
> **ТЗ для бэкенда:** `TZ_MERGED_WORKFLOW.md`

- [ ] Popup: кнопка «Работа в чатах» (отложено — пока используем diagnostic.html)
- [x] ChatAPI service (`src/services/chat-api.js`): getChatRules, chatOpened, sendAnchor, logError
- [x] ChatHandler background (`src/background/handlers/chat-handler.js`): обнаружение вкладки, парсинг якоря, API вызовы, закрытие вкладки
- [x] ChatService main world (`src/contents/complaints/services/chat-service.js`): клик по кнопке, bridge к background
- [x] MessageRouter: роуты getChatRules, processChatTab
- [x] Content.js bridge: wb-chat-request/response, wb-chat-rules-request/response
- [x] OptimizedHandler: _tryOpenChat(), _fetchChatRules(), chat stats в отчёте
- [x] Правила открытия чатов: chatEnabled + starsAllowed + chat_available + «Жалоба отклонена» + блокирующие статусы
- [x] Build: проходит без ошибок
- [ ] Smoke test: 5–10 отзывов → данные появились в БД

### Этап 3 — Отправка сообщений (после MVP)
- [ ] Архитектурное решение: бэкенд (WB API) vs расширение (UI) — по типу кабинета
- [ ] Если расширение: отправка шаблонов A/B через UI чата
- [ ] Проверка на дубли по последним N сообщениям
- [ ] POST /chat/{id}/message-sent + POST /chat/{id}/error
- [ ] Расширенная обработка ошибок
- [ ] Полировка селекторов + регресс по разным кабинетам

---

## Open Questions

| # | Вопрос | Статус |
|---|--------|--------|
| 1 | Может ли расширение парсить WB review ID из DOM? | **Решён:** НЕТ — WB убрал ID из DOM (янв 2026). Используем синтетический `reviewKey` |
| 2 | Стабилен ли формат URL чатов WB? | **Решён:** Да — `/chat-with-clients?chatId={UUID}` |
| 3 | Шаблоны сообщений — бэкенд или хардкод? | Sprint 2, не блокер |
| 4 | Кто отправляет сообщения: бэкенд (WB API) или расширение (UI)? | **TBD** — зависит от наличия WB API у кабинета. Решение — после MVP |

---

## Приложение: связанные документы

- [API_CHATS_CONTRACT.md](API_CHATS_CONTRACT.md) — контракт API (наш + бэкенд)
- [EXTENSION_INTEGRATION_GUIDE.md](EXTENSION_INTEGRATION_GUIDE.md) — гайд от бэкенд-команды
- Бэкенд-задача: `R5 saas-prod/docs/sprints/sprint-002-review-chat-linking/TASK-20260216-backend-api.md`
- Продуктовая спецификация: `R5 saas-prod/docs/sprints/sprint-002-review-chat-linking/PRODUCT_SPEC.md`
- DOM-контракт: `docs/DOM_CONTRACT.md` (секции 2.16, 2.17 — чат)
- Каталог селекторов: `src/contents/complaints/dom/selectors.catalog.js` (CHAT_* секции)
- Референсный HTML: `docs/ref/Кнопка открыть чат.html`, `docs/ref/Страница диалоги.html`

---

## Приложение: шаблоны сообщений
- Шаблон A (1–3 звезды): (подставим позже / берём с бэкенда)
- Шаблон B (4 звезды): (подставим позже / берём с бэкенда)
